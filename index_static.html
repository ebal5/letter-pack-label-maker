<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¬ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ãƒ©ãƒ™ãƒ«ä½œæˆï¼ˆé™çš„ç‰ˆï¼‰</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        .subtitle {
            opacity: 0.9;
            font-size: 14px;
        }
        .content {
            padding: 40px;
        }
        .section {
            margin-bottom: 35px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .section h2 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
        }
        .form-group {
            margin-bottom: 18px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
            font-size: 14px;
        }
        input[type="text"], select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s;
        }
        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .btn-container {
            text-align: center;
            margin-top: 30px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .alert {
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 6px;
            font-size: 14px;
        }
        .alert-error {
            background: #fee;
            color: #c33;
            border-left: 4px solid #c33;
        }
        .alert-success {
            background: #efe;
            color: #3c3;
            border-left: 4px solid #3c3;
        }
        .alert-info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        }
        footer {
            text-align: center;
            padding: 20px;
            color: #999;
            font-size: 12px;
            background: #f8f9fa;
        }
        .example {
            font-size: 12px;
            color: #999;
            margin-top: 4px;
        }
        #loading-status {
            display: none;
        }
        #loading-status.show {
            display: block;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ“® ãƒ¬ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ãƒ©ãƒ™ãƒ«ä½œæˆ</h1>
            <p class="subtitle">ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã ã‘ã§å‹•ä½œï¼ˆã‚µãƒ¼ãƒãƒ¼ä¸è¦ï¼‰</p>
        </header>

        <div class="content">
            <div id="loading-status" class="alert alert-info show">
                <div class="spinner" style="margin-right: 10px;"></div>
                Pyodideã‚’åˆæœŸåŒ–ä¸­...ï¼ˆåˆå›ã¯10ç§’ç¨‹åº¦ã‹ã‹ã‚Šã¾ã™ï¼‰
            </div>

            <div id="error-message"></div>

            <form id="label-form" style="display:none;">
                <div class="section">
                    <h2>ğŸ“¬ ãŠå±Šã‘å…ˆ</h2>
                    <div class="form-group">
                        <label for="to_postal">éƒµä¾¿ç•ªå· *</label>
                        <input type="text" id="to_postal" name="to_postal"
                               placeholder="ä¾‹: 123-4567" required>
                    </div>
                    <div class="form-group">
                        <label for="to_address">ä½æ‰€ *</label>
                        <input type="text" id="to_address" name="to_address"
                               placeholder="ä¾‹: æ±äº¬éƒ½æ¸‹è°·åŒºXXX 1-2-3 XXXãƒ“ãƒ«4F" required>
                    </div>
                    <div class="form-group">
                        <label for="to_name">æ°å *</label>
                        <input type="text" id="to_name" name="to_name"
                               placeholder="ä¾‹: å±±ç”° å¤ªéƒ" required>
                    </div>
                    <div class="form-group">
                        <label for="to_honorific">æ•¬ç§°</label>
                        <input type="text" id="to_honorific" name="to_honorific"
                               placeholder="ä¾‹: æ§˜ã€æ®¿ã€å¾¡ä¸­ã€è¡Œï¼ˆæœªå…¥åŠ›ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€Œæ§˜ã€ï¼‰" value="æ§˜">
                        <p class="example">â€» æœªå…¥åŠ›ã®å ´åˆã¯ã€Œæ§˜ã€ãŒä½¿ç”¨ã•ã‚Œã¾ã™</p>
                    </div>
                    <div class="form-group">
                        <label for="to_phone">é›»è©±ç•ªå·</label>
                        <input type="text" id="to_phone" name="to_phone"
                               placeholder="ä¾‹: 03-1234-5678">
                    </div>
                </div>

                <div class="section">
                    <h2>ğŸ“¤ ã”ä¾é ¼ä¸»</h2>
                    <div class="form-group">
                        <label for="from_postal">éƒµä¾¿ç•ªå· *</label>
                        <input type="text" id="from_postal" name="from_postal"
                               placeholder="ä¾‹: 987-6543" required>
                    </div>
                    <div class="form-group">
                        <label for="from_address">ä½æ‰€ *</label>
                        <input type="text" id="from_address" name="from_address"
                               placeholder="ä¾‹: å¤§é˜ªåºœå¤§é˜ªå¸‚YYY 4-5-6" required>
                    </div>
                    <div class="form-group">
                        <label for="from_name">æ°å *</label>
                        <input type="text" id="from_name" name="from_name"
                               placeholder="ä¾‹: ç”°ä¸­ èŠ±å­" required>
                    </div>
                    <div class="form-group">
                        <label for="from_honorific">æ•¬ç§°</label>
                        <input type="text" id="from_honorific" name="from_honorific"
                               placeholder="ä¾‹: æ§˜ã€æ®¿ã€å¾¡ä¸­ã€è¡Œï¼ˆæœªå…¥åŠ›ã§æ•¬ç§°ãªã—ï¼‰" value="">
                        <p class="example">â€» æœªå…¥åŠ›ã®å ´åˆã¯æ•¬ç§°ãªã—ã«ãªã‚Šã¾ã™</p>
                    </div>
                    <div class="form-group">
                        <label for="from_phone">é›»è©±ç•ªå·</label>
                        <input type="text" id="from_phone" name="from_phone"
                               placeholder="ä¾‹: 06-9876-5432">
                    </div>
                </div>

                <div class="section">
                    <h2>âš™ï¸ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š</h2>
                    <div class="form-group">
                        <label for="layout_mode">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰</label>
                        <select id="layout_mode" name="layout_mode">
                            <option value="center">ä¸­å¤®é…ç½®ï¼ˆ1æšï¼‰</option>
                            <option value="grid_4up">4ä¸ä»˜ï¼ˆ2Ã—2ã‚°ãƒªãƒƒãƒ‰ã€åŒã˜ãƒ©ãƒ™ãƒ«4æšï¼‰</option>
                        </select>
                        <p class="example">â€» 4ä¸ä»˜ã‚’é¸æŠã™ã‚‹ã¨ã€A4ç”¨ç´™ã«åŒã˜ãƒ©ãƒ™ãƒ«ãŒ4ã¤å°åˆ·ã•ã‚Œã¾ã™</p>
                    </div>
                </div>

                <div class="btn-container">
                    <button type="submit" id="generate-btn">ğŸ“„ PDFã‚’ç”Ÿæˆ</button>
                </div>
            </form>

            <div id="csv-form-container" style="display:none; margin-top: 50px; padding-top: 40px; border-top: 2px solid #e0e0e0;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <button type="button" id="download-sample-csv-btn" style="background: #4CAF50; padding: 12px 25px; font-size: 14px;">
                        ğŸ“¥ ã‚µãƒ³ãƒ—ãƒ«CSVã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    </button>
                </div>

                <div class="section">
                    <h2>ğŸ“Š CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ä¸€æ‹¬ç”Ÿæˆ</h2>
                    <div class="form-group">
                        <label for="csv_file">CSVãƒ•ã‚¡ã‚¤ãƒ« *</label>
                        <input type="file" id="csv_file" name="csv_file" accept=".csv"
                               style="padding: 10px; border: 2px dashed #667eea; border-radius: 6px; background: #f8f9fa;">
                        <p class="example">
                            â€» CSVå½¢å¼ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼è¡Œå¿…é ˆï¼‰: to_postal, to_address, to_name, to_phone, to_honorific,
                            from_postal, from_address, from_name, from_phone, from_honorific
                        </p>
                    </div>
                </div>
                <div class="btn-container">
                    <button type="button" id="generate-csv-btn">ğŸ“Š CSVã‹ã‚‰ä¸€æ‹¬ç”Ÿæˆ</button>
                </div>
            </div>
        </div>

        <footer>
            Letter Pack Label Maker v0.2.0 (Static) | MIT License
        </footer>
    </div>

    <script>
        let pyodide = null;
        let pythonInitialized = false;

        // ============================================
        // Pyodide Integration Agent
        // Performance metrics and diagnostics
        // ============================================

        window.pyodideMetrics = {
            pyodideLoad: 0,
            micropipLoad: 0,
            reportlabInstall: 0,
            fontDownload: 0,
            fontMount: 0,
            pythonCodeLoad: 0,
            total: 0,
            startTime: null
        };

        /**
         * Diagnostics and Performance Monitoring
         */
        class PyodideDiagnostics {
            static async generateReport() {
                const report = {
                    pyodideVersion: pyodide?.version || 'unknown',
                    pythonVersion: '3.11',
                    initializedAt: new Date().toISOString(),
                    metrics: { ...window.pyodideMetrics },
                    environment: {
                        userAgent: navigator.userAgent,
                        onLine: navigator.onLine,
                        memoryCaps: this._getMemoryCaps()
                    },
                    fontStatus: this._checkFontStatus(),
                    errors: []
                };
                return report;
            }

            static _getMemoryCaps() {
                if (performance && performance.memory) {
                    return {
                        jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB',
                        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',
                        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB'
                    };
                }
                return null;
            }

            static _checkFontStatus() {
                // windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ç¢ºå®Ÿã«pyodideã‚’å–å¾—
                const pyodideInstance = window.pyodide || pyodide;

                if (!pyodideInstance) {
                    return { status: 'not_initialized', error: 'pyodide is null or undefined' };
                }

                try {
                    // ã¾ãšPyodide FSãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèª
                    if (!pyodideInstance.FS || typeof pyodideInstance.FS.stat !== 'function') {
                        return { status: 'error', error: 'Pyodide FS not available' };
                    }

                    // ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å†…å®¹ã‚’ç¢ºèªï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                    let rootFiles = [];
                    try {
                        rootFiles = pyodideInstance.FS.readdir('/');
                        console.log('Pyodide FS root files:', rootFiles);
                    } catch (readdirError) {
                        console.warn('FS.readdir() failed:', readdirError);
                    }

                    // stat() ã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚’ç¢ºèª
                    const stat = pyodideInstance.FS.stat('/NotoSansJP-Bold.ttf');
                    console.log('Font stat result:', stat);
                    return {
                        status: stat && stat.size > 0 ? 'loaded' : 'missing',
                        path: '/NotoSansJP-Bold.ttf',
                        size: stat ? stat.size : 0
                    };
                } catch (e) {
                    // è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’è¨˜éŒ²
                    console.error('_checkFontStatus() error:', e);
                    return {
                        status: 'missing',
                        path: '/NotoSansJP-Bold.ttf',
                        error: e.message || String(e),
                        errorDetails: e.toString()
                    };
                }
            }

            static logMetrics() {
                console.table(window.pyodideMetrics);
            }

            static async sendReport(endpoint) {
                const report = await this.generateReport();
                console.log('Pyodide Diagnostic Report:', report);
                return report;
            }
        }

        // Expose to window for testing
        window.PyodideDiagnostics = PyodideDiagnostics;

        /**
         * IndexedDB Font Caching
         */
        class FontCacheManager {
            static DB_NAME = 'letterpack-fonts';
            static DB_VERSION = 1;
            static STORE_NAME = 'fonts';

            static async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                            db.createObjectStore(this.STORE_NAME);
                        }
                    };
                });
            }

            static async get(fontName) {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readonly');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.get(fontName);

                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                    });
                } catch (e) {
                    console.warn('Font cache read error:', e);
                    return null;
                }
            }

            static async set(fontName, fontData) {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.put(fontData, fontName);

                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(true);
                    });
                } catch (e) {
                    console.warn('Font cache write error:', e);
                    return false;
                }
            }

            static async clear() {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.clear();

                        request.onerror = () => reject(request.error);

                        // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å®Œäº†ã‚’å¾…ã¤ï¼ˆç¢ºå®Ÿã«ã‚³ãƒŸãƒƒãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                        transaction.oncomplete = () => {
                            db.close(); // DBã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦ç¢ºå®Ÿã«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                            resolve(true);
                        };
                        transaction.onerror = () => reject(transaction.error);
                    });
                } catch (e) {
                    console.warn('Font cache clear error:', e);
                    return false;
                }
            }
        }

        // Expose to window for testing
        window.FontCacheManager = FontCacheManager;

        /**
         * Enhanced Error Handler
         */
        class ErrorHandler {
            static networkErrors = [
                'NetworkError',
                'TypeError',
                'Failed to fetch'
            ];

            static getFriendlyMessage(error) {
                const msg = error.message || String(error);

                if (this.networkErrors.some(e => msg.includes(e))) {
                    return 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                }

                if (msg.includes('reportlab')) {
                    return 'ReportLabã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚';
                }

                if (msg.includes('font')) {
                    return 'ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚';
                }

                if (msg.includes('memory') || msg.includes('heap')) {
                    return 'ãƒ¡ãƒ¢ãƒªä¸è¶³ã§ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã‚’å†èµ·å‹•ã—ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
                }

                return error.message || 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
            }

            static logError(context, error) {
                console.error(`[${context}] Error:`, error);
                const report = {
                    context,
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    metrics: { ...window.pyodideMetrics }
                };
                console.log('Error Report:', JSON.stringify(report, null, 2));
            }
        }

        // Expose to window for testing
        window.ErrorHandler = ErrorHandler;

        // Python labelç”Ÿæˆã‚³ãƒ¼ãƒ‰ï¼ˆNoto Sans JPä½¿ç”¨ç‰ˆï¼‰
        const labelPythonCode = `
from dataclasses import dataclass
from typing import Optional
from io import BytesIO

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase.cidfonts import UnicodeCIDFont

@dataclass
class AddressInfo:
    postal_code: str
    address: str
    name: str
    phone: Optional[str] = None
    honorific: Optional[str] = None

    def __post_init__(self):
        if not self.postal_code:
            raise ValueError("éƒµä¾¿ç•ªå·ã¯å¿…é ˆã§ã™")
        if not self.address:
            raise ValueError("ä½æ‰€ã¯å¿…é ˆã§ã™")
        if not self.name:
            raise ValueError("æ°åã¯å¿…é ˆã§ã™")

class LabelGenerator:
    def __init__(self, layout_mode="center", font_path=None):
        # Noto Sans JPãƒ•ã‚©ãƒ³ãƒˆã‚’å„ªå…ˆçš„ã«ä½¿ç”¨
        if font_path:
            try:
                pdfmetrics.registerFont(TTFont("NotoSansJP", font_path))
                self.font_name = "NotoSansJP"
            except Exception as e:
                print(f"Noto Sans JPã®ç™»éŒ²ã«å¤±æ•—: {e}")
                self._fallback_font()
        else:
            self._fallback_font()

        self.layout_mode = layout_mode

    def _fallback_font(self):
        """ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†"""
        try:
            pdfmetrics.registerFont(UnicodeCIDFont("HeiseiMin-W3"))
            self.font_name = "HeiseiMin-W3"
        except:
            try:
                pdfmetrics.registerFont(UnicodeCIDFont("HeiseiKakuGo-W5"))
                self.font_name = "HeiseiKakuGo-W5"
            except:
                self.font_name = "Helvetica"

    def generate(self, to_address, from_address):
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        width, height = A4

        label_width = 105 * mm
        label_height = 148 * mm

        if self.layout_mode == "grid_4up":
            positions = [
                (0, height / 2),
                (width / 2, height / 2),
                (0, 0),
                (width / 2, 0),
            ]
            for x_offset, y_offset in positions:
                self._draw_single_label(c, to_address, from_address, x_offset, y_offset, label_width, label_height)
        else:
            x_offset = (width - label_width) / 2
            y_offset = (height - label_height) / 2
            self._draw_single_label(c, to_address, from_address, x_offset, y_offset, label_width, label_height)

        c.save()
        buffer.seek(0)
        return buffer.getvalue()

    def _draw_single_label(self, c, to_address, from_address, x_offset, y_offset, label_width, label_height):
        c.setStrokeColorRGB(0.8, 0.8, 0.8)
        c.setLineWidth(0.5)
        c.rect(x_offset, y_offset, label_width, label_height)

        section_height = label_height / 2
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(1)
        c.line(x_offset, y_offset + section_height, x_offset + label_width, y_offset + section_height)

        self._draw_address_section(c, to_address, x_offset, y_offset + section_height, label_width, section_height, "ãŠå±Šã‘å…ˆ")
        self._draw_address_section(c, from_address, x_offset, y_offset, label_width, section_height, "ã”ä¾é ¼ä¸»")

    def _draw_postal_boxes(self, c, postal_code, x, y):
        digits = postal_code.replace("-", "").replace("ã€’", "").strip()
        box_size = 5 * mm
        box_spacing = 1 * mm
        postal_font_size = 13

        c.setLineWidth(0.5)

        for i in range(3):
            box_x = x + i * (box_size + box_spacing)
            c.rect(box_x, y, box_size, box_size)
            if i < len(digits):
                c.setFont(self.font_name, postal_font_size)
                text_width = c.stringWidth(digits[i], self.font_name, postal_font_size)
                text_x = box_x + (box_size - text_width) / 2
                text_y = y + (box_size - postal_font_size) / 2 + 2
                # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
                c.setFillColorRGB(0, 0, 0)
                c.setStrokeColorRGB(0, 0, 0)
                c.setLineWidth(0.6)  # 0.4ã‹ã‚‰0.6ã«å¢—åŠ 
                # è¤‡æ•°å›æç”»ã§å¤ªã
                for dx in [-0.1, 0, 0.1]:
                    c.drawString(text_x + dx, text_y, digits[i])

        separator_x = x + 3 * (box_size + box_spacing)
        separator_y = y + box_size / 2
        separator_width = box_spacing * 1.5
        c.line(separator_x, separator_y, separator_x + separator_width, separator_y)

        offset_x = separator_x + separator_width + box_spacing
        for i in range(4):
            box_x = offset_x + i * (box_size + box_spacing)
            c.rect(box_x, y, box_size, box_size)
            digit_index = i + 3
            if digit_index < len(digits):
                c.setFont(self.font_name, postal_font_size)
                text_width = c.stringWidth(digits[digit_index], self.font_name, postal_font_size)
                text_x = box_x + (box_size - text_width) / 2
                text_y = y + (box_size - postal_font_size) / 2 + 2
                # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
                c.setFillColorRGB(0, 0, 0)
                c.setStrokeColorRGB(0, 0, 0)
                c.setLineWidth(0.6)  # 0.4ã‹ã‚‰0.6ã«å¢—åŠ 
                # è¤‡æ•°å›æç”»ã§å¤ªã
                for dx in [-0.1, 0, 0.1]:
                    c.drawString(text_x + dx, text_y, digits[digit_index])

        c.setLineWidth(1)

    def _draw_dotted_line(self, c, x1, y, x2):
        c.setDash(2, 2)
        c.setStrokeColorRGB(0.5, 0.5, 0.5)
        c.line(x1, y, x2, y)
        c.setDash()
        c.setStrokeColorRGB(0, 0, 0)

    def _draw_address_section(self, c, address, x, y, width, height, label):
        margin = 8 * mm
        current_y = y + height - margin

        c.setFont(self.font_name, 9)
        c.setFillColorRGB(0, 0, 0)
        postal_y = current_y
        # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(0.3)
        c.drawString(x + margin, postal_y, "ã€’")

        c.setFont(self.font_name, 13)
        self._draw_postal_boxes(c, address.postal_code, x + margin + 15, postal_y - 2)

        current_y -= 15
        current_y -= 15

        address_lines = self._split_address(address.address, 35)
        for line in address_lines[:3]:
            self._draw_dotted_line(c, x + margin, current_y, x + width - margin)
            address_font_size = 12  # 11ã‹ã‚‰12ã«æ‹¡å¤§
            c.setFont(self.font_name, address_font_size)
            # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
            c.setFillColorRGB(0, 0, 0)
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(0.6)  # 0.4ã‹ã‚‰0.6ã«å¢—åŠ 

            addr_x = x + margin + 4
            addr_y = current_y + 4
            # è¤‡æ•°å›æç”»ã§å¤ªã
            for dx in [-0.1, 0, 0.1]:
                c.drawString(addr_x + dx, addr_y, line)
            current_y -= 18

        for _ in range(3 - len(address_lines)):
            self._draw_dotted_line(c, x + margin, current_y, x + width - margin)
            current_y -= 18

        current_y -= 27

        honorific = address.honorific if address.honorific else ""
        if honorific:
            sama_width = 8 * mm
            name_line_end = x + width - margin - sama_width
        else:
            name_line_end = x + width - margin

        self._draw_dotted_line(c, x + margin, current_y, name_line_end)

        # æ°åã‚’å¤ªãæç”»ï¼ˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¤§ããã€è¤‡æ•°å›æç”»ã§å¼·èª¿ï¼‰
        name_font_size = 16  # 14ã‹ã‚‰16ã«æ‹¡å¤§
        c.setFont(self.font_name, name_font_size)
        c.setFillColorRGB(0, 0, 0)
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(1.0)  # 0.5ã‹ã‚‰1.0ã«æ‹¡å¤§

        name_x = x + margin + 4
        name_y = current_y + 3  # ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºãŒå¤§ãããªã£ãŸã®ã§å°‘ã—èª¿æ•´

        # è¤‡æ•°å›æç”»ã—ã¦å¤ªãè¦‹ã›ã‚‹ï¼ˆç–‘ä¼¼BoldåŠ¹æœï¼‰
        offsets = [
            (0, 0),
            (0.15, 0),
            (-0.15, 0),
            (0, 0.15),
            (0, -0.15),
        ]
        for dx, dy in offsets:
            c.drawString(name_x + dx, name_y + dy, address.name)

        if honorific:
            # æ•¬ç§°ã¯æ°åã‚ˆã‚Šå°‘ã—ç´°ã
            honorific_font_size = 14
            c.setFont(self.font_name, honorific_font_size)
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(0.5)
            sama_x = name_line_end + 2 * mm
            sama_y = current_y + 4  # æ°åã‚ˆã‚Šå°ã•ã„ã®ã§ä½ç½®èª¿æ•´

            # æ•¬ç§°ã¯å˜ç´”ãªé‡ã­æç”»ï¼ˆ3å›ï¼‰
            for dx in [-0.1, 0, 0.1]:
                c.drawString(sama_x + dx, sama_y, honorific)

        current_y -= 36

        c.setFont(self.font_name, 9)
        # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
        c.setFillColorRGB(0, 0, 0)
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(0.3)
        c.drawString(x + margin, current_y, "Tel.")

        current_y -= 15

        # é›»è©±ç•ªå·ã¯ç´°ã‚ã«ï¼ˆé›»è©±ç•ªå·ãŒã‚ã‚‹å ´åˆã®ã¿æç”»ï¼‰
        if address.phone:
            phone_font_size = 13
            c.setFont(self.font_name, phone_font_size)
            phone_text = f"( {address.phone} )"
            # è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦å¤ªãè¦‹ã›ã‚‹
            c.setFillColorRGB(0, 0, 0)
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(0.4)

            phone_x = x + margin + 30
            phone_y = current_y
            # å˜ç´”ãªæç”»ï¼ˆé‡ã­æç”»ãªã—ï¼‰
            c.drawString(phone_x, phone_y, phone_text)

    def _split_address(self, address, max_length=30):
        if len(address) <= max_length:
            return [address]

        lines = []
        current_line = ""

        for char in address:
            if len(current_line) >= max_length:
                lines.append(current_line)
                current_line = char
            else:
                current_line += char

        if current_line:
            lines.append(current_line)

        return lines

def create_label_bytes(to_info, from_info, layout_mode="center", font_path=None):
    generator = LabelGenerator(layout_mode=layout_mode, font_path=font_path)
    return generator.generate(to_info, from_info)

def create_batch_labels_bytes(label_data_list, font_path=None):
    """è¤‡æ•°ã®ãƒ©ãƒ™ãƒ«ã‚’ä¸€æ‹¬ç”Ÿæˆï¼ˆ4ä»¶ã”ã¨ã«1ãƒšãƒ¼ã‚¸ï¼‰"""
    from io import BytesIO

    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    label_width = 105 * mm
    label_height = 148 * mm

    positions = [
        (0, height / 2),
        (width / 2, height / 2),
        (0, 0),
        (width / 2, 0),
    ]

    generator = LabelGenerator(layout_mode="center", font_path=font_path)

    for page_start in range(0, len(label_data_list), 4):
        page_labels = label_data_list[page_start:page_start + 4]

        for i, (to_info, from_info) in enumerate(page_labels):
            x_offset, y_offset = positions[i]
            generator._draw_single_label(c, to_info, from_info, x_offset, y_offset, label_width, label_height)

        c.showPage()

    c.save()
    buffer.seek(0)
    return buffer.getvalue()

def parse_csv_string(csv_content):
    """CSVæ–‡å­—åˆ—ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦(to_info, from_info)ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™"""
    import io
    import csv as csv_module

    labels = []
    errors = []

    csv_file = io.StringIO(csv_content)
    reader = csv_module.DictReader(csv_file)

    required_columns = {
        "to_postal", "to_address", "to_name", "to_phone",
        "from_postal", "from_address", "from_name", "from_phone"
    }
    optional_columns = {"to_honorific", "from_honorific"}
    all_columns = required_columns | optional_columns

    if reader.fieldnames is None:
        raise ValueError("CSVãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ˜ãƒƒãƒ€ãƒ¼è¡ŒãŒã‚ã‚Šã¾ã›ã‚“")

    missing_columns = required_columns - set(reader.fieldnames)
    if missing_columns:
        raise ValueError(f"å¿…é ˆã‚«ãƒ©ãƒ ãŒä¸è¶³ã—ã¦ã„ã¾ã™: {', '.join(missing_columns)}")

    for row_number, row in enumerate(reader, start=2):
        try:
            to_postal = row.get("to_postal", "").strip()
            to_address = row.get("to_address", "").strip()
            to_name = row.get("to_name", "").strip()
            to_phone = row.get("to_phone", "").strip()
            to_honorific = row.get("to_honorific", "").strip()
            if not to_honorific:
                to_honorific = "æ§˜"

            from_postal = row.get("from_postal", "").strip()
            from_address = row.get("from_address", "").strip()
            from_name = row.get("from_name", "").strip()
            from_phone = row.get("from_phone", "").strip()
            from_honorific = row.get("from_honorific", "").strip()

            try:
                to_info = AddressInfo(
                    postal_code=to_postal,
                    address=to_address,
                    name=to_name,
                    phone=to_phone,
                    honorific=to_honorific
                )
            except ValueError as e:
                errors.append(f"è¡Œ {row_number}, ãŠå±Šã‘å…ˆ: {str(e)}")
                continue

            try:
                from_info = AddressInfo(
                    postal_code=from_postal,
                    address=from_address,
                    name=from_name,
                    phone=from_phone,
                    honorific=from_honorific
                )
            except ValueError as e:
                errors.append(f"è¡Œ {row_number}, ã”ä¾é ¼ä¸»: {str(e)}")
                continue

            labels.append((to_info, from_info))

        except Exception as e:
            errors.append(f"è¡Œ {row_number}, å…¨ä½“: {str(e)}")

    if errors:
        error_summary = "\\n".join(errors)
        raise ValueError(f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã« {len(errors)} ä»¶ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™:\\n{error_summary}")

    if not labels:
        raise ValueError("CSVãƒ•ã‚¡ã‚¤ãƒ«ã«æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")

    return labels
`;

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `<div class="alert alert-error">${message}</div>`;
            setTimeout(() => {
                errorDiv.innerHTML = '';
            }, 5000);
        }

        function showSuccess(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `<div class="alert alert-success">${message}</div>`;
            setTimeout(() => {
                errorDiv.innerHTML = '';
            }, 3000);
        }

        async function initPyodide() {
            const loadingStatus = document.getElementById('loading-status');
            const form = document.getElementById('label-form');
            const FONT_CACHE_KEY = 'noto-sans-jp-bold-v52';
            const FONT_URL = 'https://fonts.gstatic.com/s/notosansjp/v52/-F6jfjtqLzI2JPCgQBnw7HFQZoIq8q7OMa3T57qnmPk_og.ttf';

            window.pyodideMetrics.startTime = performance.now();

            try {
                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Pyodideã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...';

                let stepStart = performance.now();
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                // Pyodideã‚’windowã«å…¬é–‹ï¼ˆè¨ºæ–­APIã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ã™ã‚‹ï¼‰
                window.pyodide = pyodide;
                window.pyodideMetrics.pyodideLoad = performance.now() - stepStart;

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> ReportLabã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...';

                stepStart = performance.now();
                await pyodide.loadPackage('micropip');
                window.pyodideMetrics.micropipLoad = performance.now() - stepStart;

                stepStart = performance.now();
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install('reportlab')
                `);
                window.pyodideMetrics.reportlabInstall = performance.now() - stepStart;

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Noto Sans JPãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...';

                // Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¾ãŸã¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                try {
                    stepStart = performance.now();

                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯
                    let fontBytes = await FontCacheManager.get(FONT_CACHE_KEY);
                    let fromCache = true;

                    if (!fontBytes) {
                        fromCache = false;
                        const fontResponse = await fetch(FONT_URL);
                        if (!fontResponse.ok) {
                            throw new Error(`ãƒ•ã‚©ãƒ³ãƒˆå–å¾—å¤±æ•— (${fontResponse.status}): ${FONT_URL}`);
                        }
                        const fontArrayBuffer = await fontResponse.arrayBuffer();
                        fontBytes = new Uint8Array(fontArrayBuffer);

                        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼‰
                        await FontCacheManager.set(FONT_CACHE_KEY, fontBytes).catch(e => {
                            console.warn('ãƒ•ã‚©ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜å¤±æ•—:', e);
                        });
                    }

                    window.pyodideMetrics.fontDownload = performance.now() - stepStart;

                    // Pyodideã®ä»®æƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ä¿å­˜
                    stepStart = performance.now();
                    try {
                        pyodide.FS.writeFile('/NotoSansJP-Bold.ttf', fontBytes);
                        console.log(`ãƒ•ã‚©ãƒ³ãƒˆæ›¸ãè¾¼ã¿æˆåŠŸ: ${fontBytes.length} bytes`);
                    } catch (writeError) {
                        console.error('ãƒ•ã‚©ãƒ³ãƒˆæ›¸ãè¾¼ã¿å¤±æ•—:', writeError);
                        throw writeError; // ä¸Šä½ã®catchã«ä¼æ’­
                    }

                    // æ›¸ãè¾¼ã¿å®Œäº†ã‚’ç¢ºèªï¼ˆstat ã‚’ä½¿ç”¨ï¼‰
                    try {
                        const stat = pyodide.FS.stat('/NotoSansJP-Bold.ttf');
                        console.log(`ãƒ•ã‚©ãƒ³ãƒˆãƒã‚¦ãƒ³ãƒˆç¢ºèª: size=${stat.size}, mode=${stat.mode}`);
                    } catch (e) {
                        console.warn('ãƒ•ã‚©ãƒ³ãƒˆãƒã‚¦ãƒ³ãƒˆç¢ºèªå¤±æ•—:', e);
                        // statå¤±æ•—ã¯warningã®ã¿ï¼ˆæ›¸ãè¾¼ã¿ã¯æˆåŠŸã—ã¦ã„ã‚‹å¯èƒ½æ€§ï¼‰
                    }

                    // æœ€å°å€¤ã‚’ä¿è¨¼ï¼ˆéå¸¸ã«é«˜é€Ÿãªå ´åˆã§ã‚‚0.001msä»¥ä¸Šï¼‰
                    window.pyodideMetrics.fontMount = Math.max(performance.now() - stepStart, 0.001);

                    console.log(`Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆã®${fromCache ? 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥' : 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰'}å®Œäº† (${Math.round(fontBytes.length / 1024 / 1024 * 100) / 100}MB)`);
                } catch (fontError) {
                    ErrorHandler.logError('FontLoading', fontError);
                    console.warn('Noto Sans JP Bold ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨:', fontError.message);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¨˜éŒ²ï¼ˆã©ã¡ã‚‰ã§å¤±æ•—ã—ãŸã‹åˆ¤æ–­ã§ããªã„å ´åˆã¯ä¸¡æ–¹è¨­å®šï¼‰
                    if (!window.pyodideMetrics.fontDownload) {
                        window.pyodideMetrics.fontDownload = performance.now() - stepStart;
                    }
                    if (!window.pyodideMetrics.fontMount) {
                        window.pyodideMetrics.fontMount = 0.001; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æœ€å°å€¤
                    }
                }

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Python ã‚³ãƒ¼ãƒ‰ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...';

                stepStart = performance.now();
                pyodide.runPython(labelPythonCode);
                window.pyodideMetrics.pythonCodeLoad = performance.now() - stepStart;

                window.pyodideMetrics.total = performance.now() - window.pyodideMetrics.startTime;

                pythonInitialized = true;
                loadingStatus.classList.remove('show');
                loadingStatus.style.display = 'none';
                form.style.display = 'block';
                document.getElementById('csv-form-container').style.display = 'block';

                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’å‡ºåŠ›
                PyodideDiagnostics.logMetrics();

                showSuccess('åˆæœŸåŒ–å®Œäº†ï¼ãƒ•ã‚©ãƒ¼ãƒ ã«å…¥åŠ›ã—ã¦PDFã‚’ç”Ÿæˆã§ãã¾ã™');

            } catch (error) {
                ErrorHandler.logError('PyodideInitialization', error);
                console.error('Initialization error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                loadingStatus.innerHTML = `<div class="alert alert-error">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${friendlyMsg}</div>`;
            }
        }

        async function generatePDF(event) {
            event.preventDefault();

            if (!pythonInitialized) {
                showError('PythonãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const generateBtn = document.getElementById('generate-btn');
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> PDFç”Ÿæˆä¸­...';

            try {
                // ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿å–å¾—
                const formData = new FormData(event.target);
                const data = {
                    to_postal: formData.get('to_postal').trim(),
                    to_address: formData.get('to_address').trim(),
                    to_name: formData.get('to_name').trim(),
                    to_honorific: formData.get('to_honorific').trim() || 'æ§˜',
                    to_phone: formData.get('to_phone').trim(),
                    from_postal: formData.get('from_postal').trim(),
                    from_address: formData.get('from_address').trim(),
                    from_name: formData.get('from_name').trim(),
                    from_honorific: formData.get('from_honorific').trim(),
                    from_phone: formData.get('from_phone').trim(),
                    layout_mode: formData.get('layout_mode')
                };

                // Pythonã§pdfç”Ÿæˆï¼ˆJSONæ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™ï¼‰
                const dataJson = JSON.stringify(data);
                pyodide.globals.set('form_data_json', dataJson);
                const pdfBytes = await pyodide.runPythonAsync(`
import json

# JSONæ–‡å­—åˆ—ã‚’Pythonã®è¾æ›¸ã«å¤‰æ›
form_data = json.loads(form_data_json)

to_info = AddressInfo(
    postal_code=form_data['to_postal'],
    address=form_data['to_address'],
    name=form_data['to_name'],
    phone=form_data['to_phone'],
    honorific=form_data['to_honorific'] if form_data['to_honorific'] else None
)

from_info = AddressInfo(
    postal_code=form_data['from_postal'],
    address=form_data['from_address'],
    name=form_data['from_name'],
    phone=form_data['from_phone'],
    honorific=form_data['from_honorific'] if form_data['from_honorific'] else None
)

# Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
import os
font_path = '/NotoSansJP-Bold.ttf' if os.path.exists('/NotoSansJP-Bold.ttf') else None

pdf_bytes = create_label_bytes(to_info, from_info, form_data['layout_mode'], font_path=font_path)
pdf_bytes
                `);

                // PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([pdfBytes.toJs()], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'letterpack_label.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showSuccess('PDFã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„');

            } catch (error) {
                ErrorHandler.logError('PDFGeneration', error);
                console.error('PDF generation error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                showError(`PDFç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${friendlyMsg}`);
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'ğŸ“„ PDFã‚’ç”Ÿæˆ';
            }
        }

        async function generateFromCSV(event) {
            event.preventDefault();

            if (!pythonInitialized) {
                showError('PythonãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const csvFileInput = document.getElementById('csv_file');
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                showError('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            const file = csvFileInput.files[0];
            const generateBtn = document.getElementById('generate-csv-btn');
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> CSVå‡¦ç†ä¸­...';

            try {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
                const csvContent = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });

                // Pyodideã§ CSV ã‚’ãƒ‘ãƒ¼ã‚¹
                pyodide.globals.set('csv_content', csvContent);
                const labelData = await pyodide.runPythonAsync(`
import json

try:
    labels = parse_csv_string(csv_content)
    # AddressInfoã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’JSONäº’æ›å½¢å¼ã«å¤‰æ›
    labels_json = []
    for to_info, from_info in labels:
        labels_json.append({
            'to': {
                'postal_code': to_info.postal_code,
                'address': to_info.address,
                'name': to_info.name,
                'phone': to_info.phone,
                'honorific': to_info.honorific
            },
            'from': {
                'postal_code': from_info.postal_code,
                'address': from_info.address,
                'name': from_info.name,
                'phone': from_info.phone,
                'honorific': from_info.honorific
            }
        })

    # JSON å½¢å¼ã§è¿”ã™
    json.dumps(labels_json)
except Exception as e:
    raise ValueError(str(e))
                `);

                // JSON ã‚’ãƒ‘ãƒ¼ã‚¹
                const labelsArray = JSON.parse(labelData);

                // è¤‡æ•°ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆ
                generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> PDFç”Ÿæˆä¸­...';

                pyodide.globals.set('labels_json', JSON.stringify(labelsArray));
                const pdfBytes = await pyodide.runPythonAsync(`
import json

labels_json = pyodide.globals.get('labels_json')
labels_array = json.loads(labels_json)

# AddressInfo ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†æ§‹ç¯‰
label_data_list = []
for label in labels_array:
    to_info = AddressInfo(
        postal_code=label['to']['postal_code'],
        address=label['to']['address'],
        name=label['to']['name'],
        phone=label['to']['phone'],
        honorific=label['to']['honorific']
    )
    from_info = AddressInfo(
        postal_code=label['from']['postal_code'],
        address=label['from']['address'],
        name=label['from']['name'],
        phone=label['from']['phone'],
        honorific=label['from']['honorific']
    )
    label_data_list.append((to_info, from_info))

# Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
import os
font_path = '/NotoSansJP-Bold.ttf' if os.path.exists('/NotoSansJP-Bold.ttf') else None

# PDFç”Ÿæˆ
pdf_bytes = create_batch_labels_bytes(label_data_list, font_path=font_path)
pdf_bytes
                `);

                // PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([pdfBytes.toJs()], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'letterpack_labels_batch.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showSuccess(`${labelsArray.length}ä»¶ã®ãƒ©ãƒ™ãƒ«ã‚’CSVã‹ã‚‰ç”Ÿæˆã—ã¾ã—ãŸï¼`);
                csvFileInput.value = '';  // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ

            } catch (error) {
                ErrorHandler.logError('CSVGeneration', error);
                console.error('CSV generation error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                showError(`CSVå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${friendlyMsg}`);
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'ğŸ“Š CSVã‹ã‚‰ä¸€æ‹¬ç”Ÿæˆ';
            }
        }

        function downloadSampleCSV() {
            // ã‚µãƒ³ãƒ—ãƒ«CSVãƒ‡ãƒ¼ã‚¿
            const headers = [
                'to_postal',
                'to_address',
                'to_name',
                'to_phone',
                'to_honorific',
                'from_postal',
                'from_address',
                'from_name',
                'from_phone',
                'from_honorific'
            ];

            const sampleRows = [
                [
                    '123-4567',
                    'æ±äº¬éƒ½æ¸‹è°·åŒºXXX 1-2-3 XXXãƒ“ãƒ«4F',
                    'å±±ç”° å¤ªéƒ',
                    '03-1234-5678',
                    '',
                    '987-6543',
                    'å¤§é˜ªåºœå¤§é˜ªå¸‚YYY 4-5-6',
                    'ç”°ä¸­ èŠ±å­',
                    '06-9876-5432',
                    ''
                ],
                [
                    '111-2222',
                    'äº¬éƒ½åºœäº¬éƒ½å¸‚ZZZ 7-8-9',
                    'ä½è—¤ æ¬¡éƒ',
                    '075-111-2222',
                    'æ§˜',
                    '555-6666',
                    'ç¦å²¡çœŒç¦å²¡å¸‚AAA 10-11-12',
                    'éˆ´æœ¨ ç¾å’²',
                    '092-555-6666',
                    'ä¸€éƒ'
                ]
            ];

            // CSVã‚’ç”Ÿæˆ
            let csv = headers.join(',') + '\n';
            sampleRows.forEach(row => {
                csv += row.map(cell => {
                    // ã‚«ãƒ³ãƒã‚„ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’å«ã‚€å ´åˆã¯ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã‚€
                    if (cell.includes(',') || cell.includes('"')) {
                        return '"' + cell.replace(/"/g, '""') + '"';
                    }
                    return cell;
                }).join(',') + '\n';
            });

            // Blobã‚’ä½œæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([csv], { type: 'text/csv; charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sample.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        document.getElementById('label-form').addEventListener('submit', generatePDF);
        document.getElementById('generate-csv-btn').addEventListener('click', generateFromCSV);
        document.getElementById('download-sample-csv-btn').addEventListener('click', downloadSampleCSV);

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«åˆæœŸåŒ–
        window.addEventListener('load', initPyodide);
    </script>
</body>
</html>
