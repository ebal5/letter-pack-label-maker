<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¬ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ãƒ©ãƒ™ãƒ«ä½œæˆï¼ˆé™çš„ç‰ˆï¼‰</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        .subtitle {
            opacity: 0.9;
            font-size: 14px;
        }
        .content {
            padding: 40px;
        }
        .section {
            margin-bottom: 35px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .section h2 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
        }
        .form-group {
            margin-bottom: 18px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
            font-size: 14px;
        }
        input[type="text"], select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s;
        }
        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .btn-container {
            text-align: center;
            margin-top: 30px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .alert {
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 6px;
            font-size: 14px;
        }
        .alert-error {
            background: #fee;
            color: #c33;
            border-left: 4px solid #c33;
        }
        .alert-success {
            background: #efe;
            color: #3c3;
            border-left: 4px solid #3c3;
        }
        .alert-info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        }
        footer {
            text-align: center;
            padding: 20px;
            color: #999;
            font-size: 12px;
            background: #f8f9fa;
        }
        .example {
            font-size: 12px;
            color: #999;
            margin-top: 4px;
        }
        #loading-status {
            display: none;
        }
        #loading-status.show {
            display: block;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ“® ãƒ¬ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ãƒ©ãƒ™ãƒ«ä½œæˆ</h1>
            <p class="subtitle">ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã ã‘ã§å‹•ä½œï¼ˆã‚µãƒ¼ãƒãƒ¼ä¸è¦ï¼‰</p>
        </header>

        <div class="content">
            <div id="loading-status" class="alert alert-info show">
                <div class="spinner" style="margin-right: 10px;"></div>
                Pyodideã‚’åˆæœŸåŒ–ä¸­...ï¼ˆåˆå›ã¯10ç§’ç¨‹åº¦ã‹ã‹ã‚Šã¾ã™ï¼‰
            </div>

            <div id="error-message"></div>

            <form id="label-form" style="display:none;">
                <div class="section">
                    <h2>ğŸ“¬ ãŠå±Šã‘å…ˆ</h2>
                    <div class="form-group">
                        <label for="to_postal">éƒµä¾¿ç•ªå· *</label>
                        <input type="text" id="to_postal" name="to_postal"
                               placeholder="ä¾‹: 123-4567" required>
                    </div>
                    <div class="form-group">
                        <label for="to_address1">ä½æ‰€1è¡Œç›® *</label>
                        <input type="text" id="to_address1" name="to_address1"
                               placeholder="ä¾‹: æ±äº¬éƒ½æ¸‹è°·åŒºXXX 1-2-3" required>
                    </div>
                    <div class="form-group">
                        <label for="to_address2">ä½æ‰€2è¡Œç›®</label>
                        <input type="text" id="to_address2" name="to_address2"
                               placeholder="ä¾‹: XXXãƒ“ãƒ«4F">
                    </div>
                    <div class="form-group">
                        <label for="to_address3">ä½æ‰€3è¡Œç›®</label>
                        <input type="text" id="to_address3" name="to_address3"
                               placeholder="">
                    </div>
                    <div class="form-group">
                        <label for="to_name">æ°å *</label>
                        <input type="text" id="to_name" name="to_name"
                               placeholder="ä¾‹: å±±ç”° å¤ªéƒ" required>
                    </div>
                    <div class="form-group">
                        <label for="to_honorific">æ•¬ç§°</label>
                        <input type="text" id="to_honorific" name="to_honorific"
                               placeholder="ä¾‹: æ§˜ã€æ®¿ã€å¾¡ä¸­ã€è¡Œï¼ˆæœªå…¥åŠ›ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€Œæ§˜ã€ï¼‰" value="æ§˜">
                        <p class="example">â€» æœªå…¥åŠ›ã®å ´åˆã¯ã€Œæ§˜ã€ãŒä½¿ç”¨ã•ã‚Œã¾ã™</p>
                    </div>
                    <div class="form-group">
                        <label for="to_phone">é›»è©±ç•ªå·</label>
                        <input type="text" id="to_phone" name="to_phone"
                               placeholder="ä¾‹: 03-1234-5678">
                    </div>
                </div>

                <div class="section">
                    <h2>ğŸ“¤ ã”ä¾é ¼ä¸»</h2>
                    <div class="form-group">
                        <label for="from_postal">éƒµä¾¿ç•ªå· *</label>
                        <input type="text" id="from_postal" name="from_postal"
                               placeholder="ä¾‹: 987-6543" required>
                    </div>
                    <div class="form-group">
                        <label for="from_address1">ä½æ‰€1è¡Œç›® *</label>
                        <input type="text" id="from_address1" name="from_address1"
                               placeholder="ä¾‹: å¤§é˜ªåºœå¤§é˜ªå¸‚YYY 4-5-6" required>
                    </div>
                    <div class="form-group">
                        <label for="from_address2">ä½æ‰€2è¡Œç›®</label>
                        <input type="text" id="from_address2" name="from_address2"
                               placeholder="">
                    </div>
                    <div class="form-group">
                        <label for="from_address3">ä½æ‰€3è¡Œç›®</label>
                        <input type="text" id="from_address3" name="from_address3"
                               placeholder="">
                    </div>
                    <div class="form-group">
                        <label for="from_name">æ°å *</label>
                        <input type="text" id="from_name" name="from_name"
                               placeholder="ä¾‹: ç”°ä¸­ èŠ±å­" required>
                    </div>
                    <div class="form-group">
                        <label for="from_honorific">æ•¬ç§°</label>
                        <input type="text" id="from_honorific" name="from_honorific"
                               placeholder="ä¾‹: æ§˜ã€æ®¿ã€å¾¡ä¸­ã€è¡Œï¼ˆæœªå…¥åŠ›ã§æ•¬ç§°ãªã—ï¼‰" value="">
                        <p class="example">â€» æœªå…¥åŠ›ã®å ´åˆã¯æ•¬ç§°ãªã—ã«ãªã‚Šã¾ã™</p>
                    </div>
                    <div class="form-group">
                        <label for="from_phone">é›»è©±ç•ªå·</label>
                        <input type="text" id="from_phone" name="from_phone"
                               placeholder="ä¾‹: 06-9876-5432">
                    </div>
                </div>

                <div class="section">
                    <h2>âš™ï¸ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š</h2>
                    <div class="form-group">
                        <label for="layout_mode">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ¢ãƒ¼ãƒ‰</label>
                        <select id="layout_mode" name="layout_mode">
                            <option value="center">ä¸­å¤®é…ç½®ï¼ˆ1æšï¼‰</option>
                            <option value="grid_4up">4ä¸ä»˜ï¼ˆ2Ã—2ã‚°ãƒªãƒƒãƒ‰ã€åŒã˜ãƒ©ãƒ™ãƒ«4æšï¼‰</option>
                        </select>
                        <p class="example">â€» 4ä¸ä»˜ã‚’é¸æŠã™ã‚‹ã¨ã€A4ç”¨ç´™ã«åŒã˜ãƒ©ãƒ™ãƒ«ãŒ4ã¤å°åˆ·ã•ã‚Œã¾ã™</p>
                    </div>
                </div>

                <div class="btn-container">
                    <button type="submit" id="generate-btn">ğŸ“„ PDFã‚’ç”Ÿæˆ</button>
                </div>
            </form>

            <div id="csv-form-container" style="display:none; margin-top: 50px; padding-top: 40px; border-top: 2px solid #e0e0e0;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <button type="button" id="download-sample-csv-btn" style="background: #4CAF50; padding: 12px 25px; font-size: 14px;">
                        ğŸ“¥ ã‚µãƒ³ãƒ—ãƒ«CSVã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    </button>
                </div>

                <div class="section">
                    <h2>ğŸ“Š CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ä¸€æ‹¬ç”Ÿæˆ</h2>
                    <div class="form-group">
                        <label for="csv_file">CSVãƒ•ã‚¡ã‚¤ãƒ« *</label>
                        <input type="file" id="csv_file" name="csv_file" accept=".csv"
                               style="padding: 10px; border: 2px dashed #667eea; border-radius: 6px; background: #f8f9fa;">
                        <p class="example">
                            â€» CSVå½¢å¼ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼è¡Œå¿…é ˆï¼‰: to_postal, to_address1, to_address2, to_address3, to_name, to_phone, to_honorific,
                            from_postal, from_address1, from_address2, from_address3, from_name, from_phone, from_honorific
                        </p>
                    </div>
                </div>
                <div class="btn-container">
                    <button type="button" id="generate-csv-btn">ğŸ“Š CSVã‹ã‚‰ä¸€æ‹¬ç”Ÿæˆ</button>
                </div>
            </div>
        </div>

        <footer>
            Letter Pack Label Maker v0.2.0 (Static) | MIT License
        </footer>
    </div>

    <script>
        let pyodide = null;
        let pythonInitialized = false;

        // ============================================
        // Pyodide Integration Agent
        // Performance metrics and diagnostics
        // ============================================

        window.pyodideMetrics = {
            pyodideLoad: 0,
            micropipLoad: 0,
            reportlabInstall: 0,
            fontDownload: 0,
            fontMount: 0,
            pythonCodeLoad: 0,
            total: 0,
            startTime: null
        };

        /**
         * Diagnostics and Performance Monitoring
         */
        class PyodideDiagnostics {
            static async generateReport() {
                const report = {
                    pyodideVersion: pyodide?.version || 'unknown',
                    pythonVersion: '3.11',
                    initializedAt: new Date().toISOString(),
                    metrics: { ...window.pyodideMetrics },
                    environment: {
                        userAgent: navigator.userAgent,
                        onLine: navigator.onLine,
                        memoryCaps: this._getMemoryCaps()
                    },
                    fontStatus: this._checkFontStatus(),
                    errors: []
                };
                return report;
            }

            static _getMemoryCaps() {
                // è­¦å‘Š: performance.memory ã¯ Chrome/Edge é™å®šã®éæ¨™æº–APIã§ã™
                // Firefoxã€Safari ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“
                // å°†æ¥çš„ã«å»ƒæ­¢ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ãƒ¡ãƒ¢ãƒªæƒ…å ±ãŒå–å¾—ã§ããªã„å ´åˆã‚‚è€ƒæ…®ã—ã¦ãã ã•ã„
                if (typeof performance !== 'undefined' &&
                    performance.memory &&
                    typeof performance.memory.jsHeapSizeLimit === 'number') {
                    try {
                        return {
                            jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB',
                            totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',
                            usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                            note: 'Chrome/Edge only (non-standard API)'
                        };
                    } catch (e) {
                        console.warn('Failed to get memory caps:', e);
                    }
                }
                return { note: 'Memory API not available in this browser' };
            }

            static _checkFontStatus() {
                // windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ç¢ºå®Ÿã«pyodideã‚’å–å¾—
                const pyodideInstance = window.pyodide || pyodide;

                if (!pyodideInstance) {
                    return { status: 'not_initialized', error: 'pyodide is null or undefined' };
                }

                try {
                    // ã¾ãšPyodide FSãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèª
                    if (!pyodideInstance.FS || typeof pyodideInstance.FS.stat !== 'function') {
                        return { status: 'error', error: 'Pyodide FS not available' };
                    }

                    // ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å†…å®¹ã‚’ç¢ºèªï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                    let rootFiles = [];
                    try {
                        rootFiles = pyodideInstance.FS.readdir('/');
                        console.log('Pyodide FS root files:', rootFiles);
                    } catch (readdirError) {
                        console.warn('FS.readdir() failed:', readdirError);
                    }

                    // stat() ã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚’ç¢ºèª
                    const stat = pyodideInstance.FS.stat('/NotoSansJP-Bold.ttf');
                    console.log('Font stat result:', stat);
                    return {
                        status: stat && stat.size > 0 ? 'loaded' : 'missing',
                        path: '/NotoSansJP-Bold.ttf',
                        size: stat ? stat.size : 0
                    };
                } catch (e) {
                    // è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’è¨˜éŒ²
                    console.error('_checkFontStatus() error:', e);
                    return {
                        status: 'missing',
                        path: '/NotoSansJP-Bold.ttf',
                        error: e.message || String(e),
                        errorDetails: e.toString()
                    };
                }
            }

            static logMetrics() {
                console.table(window.pyodideMetrics);
            }

            static async sendReport(endpoint) {
                const report = await this.generateReport();
                console.log('Pyodide Diagnostic Report:', report);
                return report;
            }
        }

        // PyodideDiagnosticsã‚¯ãƒ©ã‚¹ã®å®šç¾©å®Œäº†ï¼ˆå¾Œã§çµ±ä¸€åå‰ç©ºé–“ã«å…¬é–‹ï¼‰

        /**
         * IndexedDB Font Caching
         */
        class FontCacheManager {
            static DB_NAME = 'letterpack-fonts';
            static DB_VERSION = 1;
            static STORE_NAME = 'fonts';

            static async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                            db.createObjectStore(this.STORE_NAME);
                        }
                    };
                });
            }

            static async get(fontName) {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readonly');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.get(fontName);

                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                    });
                } catch (e) {
                    console.warn('Font cache read error:', e);
                    return null;
                }
            }

            static async set(fontName, fontData) {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.put(fontData, fontName);

                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(true);
                    });
                } catch (e) {
                    console.warn('Font cache write error:', e);
                    return false;
                }
            }

            static async clear() {
                try {
                    const db = await this.init();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.STORE_NAME, 'readwrite');
                        const store = transaction.objectStore(this.STORE_NAME);
                        const request = store.clear();

                        request.onerror = () => reject(request.error);

                        // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å®Œäº†ã‚’å¾…ã¤ï¼ˆç¢ºå®Ÿã«ã‚³ãƒŸãƒƒãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                        transaction.oncomplete = () => {
                            // ãƒ–ãƒ©ã‚¦ã‚¶ãŒIndexedDBæ¥ç¶šã‚’è‡ªå‹•ç®¡ç†ã™ã‚‹ãŸã‚ã€æ˜ç¤ºçš„ãªcloseã¯ä¸è¦
                            // é »ç¹ãªopen/closeã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ä½ä¸‹ã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
                            resolve(true);
                        };
                        transaction.onerror = () => reject(transaction.error);
                    });
                } catch (e) {
                    console.warn('Font cache clear error:', e);
                    return false;
                }
            }
        }

        // FontCacheManagerã‚¯ãƒ©ã‚¹ã®å®šç¾©å®Œäº†ï¼ˆå¾Œã§çµ±ä¸€åå‰ç©ºé–“ã«å…¬é–‹ï¼‰

        /**
         * Enhanced Error Handler
         */
        class ErrorHandler {
            static networkErrors = [
                'NetworkError',
                'TypeError',
                'Failed to fetch'
            ];

            static getFriendlyMessage(error) {
                const msg = error.message || String(error);

                if (this.networkErrors.some(e => msg.includes(e))) {
                    return 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                }

                if (msg.includes('reportlab')) {
                    return 'ReportLabã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚';
                }

                if (msg.includes('font')) {
                    return 'ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚';
                }

                if (msg.includes('memory') || msg.includes('heap')) {
                    return 'ãƒ¡ãƒ¢ãƒªä¸è¶³ã§ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã‚’å†èµ·å‹•ã—ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
                }

                return error.message || 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
            }

            static logError(context, error) {
                console.error(`[${context}] Error:`, error);
                const report = {
                    context,
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    metrics: { ...window.pyodideMetrics }
                };
                console.log('Error Report:', JSON.stringify(report, null, 2));
            }
        }

        // ErrorHandlerã‚¯ãƒ©ã‚¹ã®å®šç¾©å®Œäº†ï¼ˆå¾Œã§çµ±ä¸€åå‰ç©ºé–“ã«å…¬é–‹ï¼‰

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ã®æ±šæŸ“ã‚’é¿ã‘ã‚‹ãŸã‚ã€çµ±ä¸€ã•ã‚ŒãŸåå‰ç©ºé–“ã«å…¬é–‹
        // ãƒ†ã‚¹ãƒˆç”¨ã®APIã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã¤ã¤ã€ä»–ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã®è¡çªã‚’é˜²ã
        window.LetterPackDebug = {
            PyodideDiagnostics,
            FontCacheManager,
            ErrorHandler
        };

        // Python labelç”Ÿæˆã‚³ãƒ¼ãƒ‰ï¼ˆNoto Sans JPä½¿ç”¨ç‰ˆ + Pydanticè¨­å®šãƒ¢ãƒ‡ãƒ«ï¼‰
        const labelPythonCode = `
from dataclasses import dataclass, field
from typing import Optional, Literal
from io import BytesIO

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase.cidfonts import UnicodeCIDFont

# Pydanticäº’æ›ã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼ˆPydanticãªã—ã§å‹•ä½œã•ã›ã‚‹ãŸã‚ã€æ¨™æº–dataclassã‚’ä½¿ç”¨ï¼‰
@dataclass
class LayoutConfig:
    """ãƒ©ãƒ™ãƒ«ã®åŸºæœ¬å¯¸æ³•è¨­å®š"""
    label_width: float = 105
    label_height: float = 122
    margin_top: float = 7
    margin_left: float = 5
    draw_border: bool = True
    layout_mode: str = "center"  # "center" or "grid_4up"

@dataclass
class FontsConfig:
    """ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºè¨­å®š"""
    label: int = 9
    postal_code: int = 13
    address: int = 11
    name: int = 14
    honorific: Optional[int] = None
    phone: int = 13

@dataclass
class SpacingConfig:
    """è¦ç´ é–“ã®ã‚¹ãƒšãƒ¼ã‚·ãƒ³ã‚°è¨­å®š"""
    section_spacing: int = 15
    address_line_height: int = 18
    address_name_gap: int = 27
    name_phone_gap: int = 36
    postal_box_offset_x: int = 15
    postal_box_offset_y: int = -2
    dotted_line_text_offset: int = 4

@dataclass
class PostalBoxConfig:
    """éƒµä¾¿ç•ªå·ãƒœãƒƒã‚¯ã‚¹è¨­å®š"""
    box_size: float = 5
    box_spacing: float = 1
    line_width: float = 0.5
    text_vertical_offset: float = 2

@dataclass
class AddressLayoutConfig:
    """ä½æ‰€ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š"""
    max_length: int = 35
    max_lines: int = 3

@dataclass
class DottedLineConfig:
    """ç‚¹ç·šã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š"""
    dash_length: float = 2
    dash_spacing: float = 2
    color_r: float = 0.5
    color_g: float = 0.5
    color_b: float = 0.5

@dataclass
class SamaConfig:
    """ã€Œæ§˜ã€ã®é…ç½®è¨­å®š"""
    width: float = 8
    offset: float = 2

@dataclass
class BorderConfig:
    """æ ç·šã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰"""
    color_r: float = 0.8
    color_g: float = 0.8
    color_b: float = 0.8
    line_width: float = 0.5

@dataclass
class PhoneConfig:
    """é›»è©±ç•ªå·ã®é…ç½®è¨­å®š"""
    offset_x: int = 30

@dataclass
class SectionHeightConfig:
    """ã‚»ã‚¯ã‚·ãƒ§ãƒ³é«˜ã•è¨­å®šï¼ˆå®Ÿæ¸¬å€¤ãƒ™ãƒ¼ã‚¹ï¼‰"""
    to_section_height: float = 69
    from_section_height: float = 53
    from_section_font_scale: float = 0.7
    from_address_max_lines: int = 2
    from_address_name_gap: int = 9
    from_name_phone_gap: int = 12
    from_address_font_size_adjust: int = 2

@dataclass
class LabelLayoutConfig:
    """ãƒ¬ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ãƒ©ãƒ™ãƒ«ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå…¨ä½“è¨­å®š"""
    layout: LayoutConfig = field(default_factory=LayoutConfig)
    fonts: FontsConfig = field(default_factory=FontsConfig)
    spacing: SpacingConfig = field(default_factory=SpacingConfig)
    postal_box: PostalBoxConfig = field(default_factory=PostalBoxConfig)
    address: AddressLayoutConfig = field(default_factory=AddressLayoutConfig)
    dotted_line: DottedLineConfig = field(default_factory=DottedLineConfig)
    sama: SamaConfig = field(default_factory=SamaConfig)
    border: BorderConfig = field(default_factory=BorderConfig)
    phone: PhoneConfig = field(default_factory=PhoneConfig)
    section_height: SectionHeightConfig = field(default_factory=SectionHeightConfig)

def load_layout_config(config_path=None):
    """ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆYAMLèª­ã¿è¾¼ã¿ã¯æ¬¡ã®ã‚¿ã‚¹ã‚¯ã§å®Ÿè£…ï¼‰"""
    if config_path is None:
        return LabelLayoutConfig()
    raise NotImplementedError("YAML loading will be implemented in the next task")

@dataclass
class AddressInfo:
    postal_code: str
    address1: str
    name: str
    address2: Optional[str] = None
    address3: Optional[str] = None
    phone: Optional[str] = None
    honorific: Optional[str] = None

    def __post_init__(self):
        if not self.postal_code:
            raise ValueError("éƒµä¾¿ç•ªå·ã¯å¿…é ˆã§ã™")
        if not self.address1:
            raise ValueError("ä½æ‰€1è¡Œç›®ã¯å¿…é ˆã§ã™")
        if not self.name:
            raise ValueError("æ°åã¯å¿…é ˆã§ã™")

class LabelGenerator:
    def __init__(self, font_path=None, config_path=None):
        self.font_name = "IPAGothic"
        self.font_path = font_path
        self.config = load_layout_config(config_path)
        self._setup_font()

    def _setup_font(self):
        """ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š"""
        self.bold_font_name = None

        if self.font_path:
            try:
                pdfmetrics.registerFont(TTFont("CustomFont", self.font_path))
                self.font_name = "CustomFont"
                self.bold_font_name = "CustomFont"
                return
            except Exception as e:
                print(f"è­¦å‘Š: ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                print("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™")

        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: IPAGothic â†’ HeiseiMin-W3 â†’ HeiseiKakuGo-W5 â†’ Helvetica
        try:
            pdfmetrics.registerFont(UnicodeCIDFont("HeiseiMin-W3"))
            self.font_name = "HeiseiMin-W3"
            self.bold_font_name = "HeiseiMin-W3"
            print("è­¦å‘Š: IPAãƒ•ã‚©ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚HeiseiMin-W3ã‚’ä½¿ç”¨ã—ã¾ã™")
        except Exception as e:
            print(f"è­¦å‘Š: HeiseiMin-W3ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
            try:
                pdfmetrics.registerFont(UnicodeCIDFont("HeiseiKakuGo-W5"))
                self.font_name = "HeiseiKakuGo-W5"
                self.bold_font_name = "HeiseiKakuGo-W5"
                print("è­¦å‘Š: HeiseiKakuGo-W5ã‚’ä½¿ç”¨ã—ã¾ã™")
            except Exception as e2:
                print(f"è­¦å‘Š: HeiseiKakuGo-W5ã®ç™»éŒ²ã«ã‚‚å¤±æ•—ã—ã¾ã—ãŸ: {e2}")
                self.font_name = "Helvetica"
                self.bold_font_name = "Helvetica-Bold"
                print("è­¦å‘Š: æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚Helveticaã‚’ä½¿ç”¨ã—ã¾ã™")

    def generate(self, to_address, from_address):
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        width, height = A4

        label_width = self.config.layout.label_width * mm
        label_height = self.config.layout.label_height * mm

        if self.config.layout.layout_mode == "grid_4up":
            positions = [
                (0, height / 2),
                (width / 2, height / 2),
                (0, 0),
                (width / 2, 0),
            ]
            for x_offset, y_offset in positions:
                self._draw_single_label(c, to_address, from_address, x_offset, y_offset, label_width, label_height)
        else:
            x_offset = (width - label_width) / 2
            y_offset = (height - label_height) / 2
            self._draw_single_label(c, to_address, from_address, x_offset, y_offset, label_width, label_height)

        c.save()
        buffer.seek(0)
        return buffer.getvalue()

    def _draw_single_label(self, c, to_address, from_address, x_offset, y_offset, label_width, label_height):
        if self.config.layout.draw_border:
            c.setStrokeColorRGB(
                self.config.border.color_r,
                self.config.border.color_g,
                self.config.border.color_b,
            )
            c.setLineWidth(self.config.border.line_width)
            c.rect(x_offset, y_offset, label_width, label_height)

        to_section_height = self.config.section_height.to_section_height * mm
        from_section_height = self.config.section_height.from_section_height * mm

        # åŒºåˆ‡ã‚Šç·šï¼ˆå¤ªã•ã¯2.5ãƒã‚¤ãƒ³ãƒˆå›ºå®šï¼‰
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(2.5)
        divider_y = y_offset + from_section_height
        c.line(x_offset, divider_y, x_offset + label_width, divider_y)

        self._draw_address_section(
            c, to_address, x_offset, divider_y, label_width, to_section_height,
            "ãŠå±Šã‘å…ˆ", font_scale=1.0
        )
        self._draw_address_section(
            c, from_address, x_offset, y_offset, label_width, from_section_height,
            "ã”ä¾é ¼ä¸»", font_scale=self.config.section_height.from_section_font_scale
        )

    def _draw_postal_boxes(self, c, postal_code, x, y, font_scale=1.0):
        digits = postal_code.replace("-", "").replace("ã€’", "").strip()
        box_size = self.config.postal_box.box_size * mm
        box_spacing = self.config.postal_box.box_spacing * mm
        box_line_width = self.config.postal_box.line_width
        text_vertical_offset = self.config.postal_box.text_vertical_offset
        postal_font_size = int(self.config.fonts.postal_code * font_scale)

        bold_font_name = getattr(self, "bold_font_name", self.font_name)
        c.setLineWidth(box_line_width)

        for i in range(3):
            box_x = x + i * (box_size + box_spacing)
            c.rect(box_x, y, box_size, box_size)
            if i < len(digits):
                c.setFont(bold_font_name, postal_font_size)
                text_width = c.stringWidth(digits[i], bold_font_name, postal_font_size)
                text_x = box_x + (box_size - text_width) / 2
                text_y = y + (box_size - postal_font_size) / 2 + text_vertical_offset
                c.drawString(text_x, text_y, digits[i])

        separator_x = x + 3 * (box_size + box_spacing)
        separator_y = y + box_size / 2
        separator_width = box_spacing * 1.5
        c.setLineWidth(box_line_width)
        c.line(separator_x, separator_y, separator_x + separator_width, separator_y)

        offset_x = separator_x + separator_width + box_spacing
        for i in range(4):
            box_x = offset_x + i * (box_size + box_spacing)
            c.rect(box_x, y, box_size, box_size)
            digit_index = i + 3
            if digit_index < len(digits):
                c.setFont(bold_font_name, postal_font_size)
                text_width = c.stringWidth(digits[digit_index], bold_font_name, postal_font_size)
                text_x = box_x + (box_size - text_width) / 2
                text_y = y + (box_size - postal_font_size) / 2 + text_vertical_offset
                c.drawString(text_x, text_y, digits[digit_index])

        c.setLineWidth(1)

    def _draw_dotted_line(self, c, x1, y, x2):
        c.setDash(self.config.dotted_line.dash_length, self.config.dotted_line.dash_spacing)
        c.setStrokeColorRGB(
            self.config.dotted_line.color_r,
            self.config.dotted_line.color_g,
            self.config.dotted_line.color_b,
        )
        c.line(x1, y, x2, y)
        c.setDash()
        c.setStrokeColorRGB(0, 0, 0)

    def _draw_address_section(self, c, address, x, y, width, height, label, font_scale=1.0):
        is_from_section = label == "ã”ä¾é ¼ä¸»"

        margin_top = self.config.layout.margin_top * mm
        margin_left = self.config.layout.margin_left * mm
        current_y = y + height - margin_top

        label_font_size = int(self.config.fonts.label * font_scale)
        postal_mark_font_size = self.config.fonts.label

        if is_from_section:
            address_font_size = int(
                (self.config.fonts.address + self.config.section_height.from_address_font_size_adjust) * font_scale
            )
        else:
            address_font_size = int(self.config.fonts.address * font_scale)

        name_font_size = int(self.config.fonts.name * font_scale)
        phone_font_size = int(self.config.fonts.phone * font_scale)

        section_spacing = self.config.spacing.section_spacing
        address_line_height = self.config.spacing.address_line_height
        address_name_gap = (
            self.config.section_height.from_address_name_gap if is_from_section
            else self.config.spacing.address_name_gap
        )
        name_phone_gap = (
            self.config.section_height.from_name_phone_gap if is_from_section
            else self.config.spacing.name_phone_gap
        )
        postal_box_offset_x = self.config.spacing.postal_box_offset_x
        postal_box_offset_y = self.config.spacing.postal_box_offset_y
        dotted_line_text_offset = self.config.spacing.dotted_line_text_offset

        c.setFont(self.font_name, postal_mark_font_size)
        c.setFillColorRGB(0, 0, 0)
        postal_y = current_y
        c.drawString(x + margin_left, postal_y, "ã€’")

        postal_font_size_scaled = int(self.config.fonts.postal_code * font_scale)
        c.setFont(self.font_name, postal_font_size_scaled)
        c.setFillColorRGB(0, 0, 0)
        self._draw_postal_boxes(
            c, address.postal_code,
            x + margin_left + postal_box_offset_x,
            postal_y + postal_box_offset_y,
            font_scale=font_scale
        )

        current_y -= section_spacing
        current_y -= section_spacing

        address_lines = [address.address1]
        if address.address2:
            address_lines.append(address.address2)
        if address.address3:
            address_lines.append(address.address3)

        max_address_lines = (
            self.config.section_height.from_address_max_lines if is_from_section
            else self.config.address.max_lines
        )

        for line in address_lines:
            self._draw_dotted_line(c, x + margin_left, current_y, x + width - margin_left)
            c.setFont(self.font_name, address_font_size)
            c.drawString(x + margin_left + dotted_line_text_offset, current_y + dotted_line_text_offset, line)
            current_y -= address_line_height

        remaining_lines = max_address_lines - len(address_lines)
        for _ in range(remaining_lines):
            self._draw_dotted_line(c, x + margin_left, current_y, x + width - margin_left)
            current_y -= address_line_height

        current_y -= address_name_gap

        honorific = address.honorific if address.honorific else ""
        if honorific:
            sama_width = self.config.sama.width * mm
            name_line_end = x + width - margin_left - sama_width
        else:
            name_line_end = x + width - margin_left

        self._draw_dotted_line(c, x + margin_left, current_y, name_line_end)

        c.setFont(self.font_name, name_font_size)
        c.setFillColorRGB(0, 0, 0)
        c.drawString(x + margin_left + dotted_line_text_offset, current_y + dotted_line_text_offset, address.name)

        if honorific:
            if self.config.fonts.honorific is not None:
                honorific_font_size = int(self.config.fonts.honorific * font_scale)
            else:
                honorific_font_size = max(name_font_size - 2, 1)
            c.setFont(self.font_name, honorific_font_size)
            c.setFillColorRGB(0, 0, 0)
            sama_x = name_line_end + self.config.sama.offset * mm
            c.drawString(sama_x, current_y + dotted_line_text_offset, honorific)

        current_y -= name_phone_gap

        if address.phone:
            c.setFont(self.font_name, label_font_size)
            c.setFillColorRGB(0, 0, 0)
            c.drawString(x + margin_left, current_y, "Tel.")

            current_y -= section_spacing

            c.setFont(self.font_name, phone_font_size)
            c.setFillColorRGB(0, 0, 0)
            phone_text = f"( {address.phone} )"
            c.drawString(x + margin_left + self.config.phone.offset_x, current_y, phone_text)

    def _split_address(self, address, max_length=30):
        if len(address) <= max_length:
            return [address]

        lines = []
        current_line = ""

        for char in address:
            if len(current_line) >= max_length:
                lines.append(current_line)
                current_line = char
            else:
                current_line += char

        if current_line:
            lines.append(current_line)

        return lines

def create_label_bytes(to_info, from_info, layout_mode="center", font_path=None):
    generator = LabelGenerator(font_path=font_path, config_path=None)
    # layout_modeã¯è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åæ˜ 
    generator.config.layout.layout_mode = layout_mode
    return generator.generate(to_info, from_info)

def create_batch_labels_bytes(label_data_list, font_path=None):
    """è¤‡æ•°ã®ãƒ©ãƒ™ãƒ«ã‚’ä¸€æ‹¬ç”Ÿæˆï¼ˆ4ä»¶ã”ã¨ã«1ãƒšãƒ¼ã‚¸ï¼‰"""
    from io import BytesIO

    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    generator = LabelGenerator(font_path=font_path, config_path=None)
    label_width = generator.config.layout.label_width * mm
    label_height = generator.config.layout.label_height * mm

    positions = [
        (0, height / 2),
        (width / 2, height / 2),
        (0, 0),
        (width / 2, 0),
    ]

    for page_start in range(0, len(label_data_list), 4):
        page_labels = label_data_list[page_start:page_start + 4]

        for i, (to_info, from_info) in enumerate(page_labels):
            x_offset, y_offset = positions[i]
            generator._draw_single_label(c, to_info, from_info, x_offset, y_offset, label_width, label_height)

        c.showPage()

    c.save()
    buffer.seek(0)
    return buffer.getvalue()

def parse_csv_string(csv_content):
    """CSVæ–‡å­—åˆ—ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦(to_info, from_info)ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™"""
    import io
    import csv as csv_module

    labels = []
    errors = []

    csv_file = io.StringIO(csv_content)
    reader = csv_module.DictReader(csv_file)

    required_columns = {
        "to_postal", "to_address1", "to_name",
        "from_postal", "from_address1", "from_name"
    }
    optional_columns = {
        "to_address2", "to_address3", "to_phone", "to_honorific",
        "from_address2", "from_address3", "from_phone", "from_honorific"
    }
    all_columns = required_columns | optional_columns

    if reader.fieldnames is None:
        raise ValueError("CSVãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ˜ãƒƒãƒ€ãƒ¼è¡ŒãŒã‚ã‚Šã¾ã›ã‚“")

    missing_columns = required_columns - set(reader.fieldnames)
    if missing_columns:
        raise ValueError(f"å¿…é ˆã‚«ãƒ©ãƒ ãŒä¸è¶³ã—ã¦ã„ã¾ã™: {', '.join(missing_columns)}")

    for row_number, row in enumerate(reader, start=2):
        try:
            to_postal = row.get("to_postal", "").strip()
            to_address1 = row.get("to_address1", "").strip()
            to_address2 = row.get("to_address2", "").strip() or None
            to_address3 = row.get("to_address3", "").strip() or None
            to_name = row.get("to_name", "").strip()
            to_phone = row.get("to_phone", "").strip() or None
            to_honorific = row.get("to_honorific", "").strip()
            if not to_honorific:
                to_honorific = "æ§˜"

            from_postal = row.get("from_postal", "").strip()
            from_address1 = row.get("from_address1", "").strip()
            from_address2 = row.get("from_address2", "").strip() or None
            from_address3 = row.get("from_address3", "").strip() or None
            from_name = row.get("from_name", "").strip()
            from_phone = row.get("from_phone", "").strip() or None
            from_honorific = row.get("from_honorific", "").strip()

            try:
                to_info = AddressInfo(
                    postal_code=to_postal,
                    address1=to_address1,
                    address2=to_address2,
                    address3=to_address3,
                    name=to_name,
                    phone=to_phone,
                    honorific=to_honorific
                )
            except ValueError as e:
                errors.append(f"è¡Œ {row_number}, ãŠå±Šã‘å…ˆ: {str(e)}")
                continue

            try:
                from_info = AddressInfo(
                    postal_code=from_postal,
                    address1=from_address1,
                    address2=from_address2,
                    address3=from_address3,
                    name=from_name,
                    phone=from_phone,
                    honorific=from_honorific
                )
            except ValueError as e:
                errors.append(f"è¡Œ {row_number}, ã”ä¾é ¼ä¸»: {str(e)}")
                continue

            labels.append((to_info, from_info))

        except Exception as e:
            errors.append(f"è¡Œ {row_number}, å…¨ä½“: {str(e)}")

    if errors:
        error_summary = "\\n".join(errors)
        raise ValueError(f"CSVãƒ•ã‚¡ã‚¤ãƒ«ã« {len(errors)} ä»¶ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™:\\n{error_summary}")

    if not labels:
        raise ValueError("CSVãƒ•ã‚¡ã‚¤ãƒ«ã«æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")

    return labels
`;

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `<div class="alert alert-error">${message}</div>`;
            setTimeout(() => {
                errorDiv.innerHTML = '';
            }, 5000);
        }

        function showSuccess(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `<div class="alert alert-success">${message}</div>`;
            setTimeout(() => {
                errorDiv.innerHTML = '';
            }, 3000);
        }

        async function initPyodide() {
            const loadingStatus = document.getElementById('loading-status');
            const form = document.getElementById('label-form');
            const FONT_CACHE_KEY = 'noto-sans-jp-bold-v52';
            const FONT_URL = 'https://fonts.gstatic.com/s/notosansjp/v52/-F6jfjtqLzI2JPCgQBnw7HFQZoIq8q7OMa3T57qnmPk_og.ttf';

            window.pyodideMetrics.startTime = performance.now();

            try {
                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Pyodideã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...';

                let stepStart = performance.now();
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                // Pyodideã‚’windowã«å…¬é–‹ï¼ˆè¨ºæ–­APIã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ã™ã‚‹ï¼‰
                window.pyodide = pyodide;
                window.pyodideMetrics.pyodideLoad = performance.now() - stepStart;

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> ReportLabã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...';

                stepStart = performance.now();
                await pyodide.loadPackage('micropip');
                window.pyodideMetrics.micropipLoad = performance.now() - stepStart;

                stepStart = performance.now();
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install('reportlab')
                `);
                window.pyodideMetrics.reportlabInstall = performance.now() - stepStart;

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Noto Sans JPãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...';

                // Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¾ãŸã¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                try {
                    stepStart = performance.now();

                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯
                    let fontBytes = await FontCacheManager.get(FONT_CACHE_KEY);
                    let fromCache = true;

                    if (!fontBytes) {
                        fromCache = false;
                        const fontResponse = await fetch(FONT_URL);
                        if (!fontResponse.ok) {
                            throw new Error(`ãƒ•ã‚©ãƒ³ãƒˆå–å¾—å¤±æ•— (${fontResponse.status}): ${FONT_URL}`);
                        }
                        const fontArrayBuffer = await fontResponse.arrayBuffer();
                        fontBytes = new Uint8Array(fontArrayBuffer);

                        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼‰
                        await FontCacheManager.set(FONT_CACHE_KEY, fontBytes).catch(e => {
                            console.warn('ãƒ•ã‚©ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜å¤±æ•—:', e);
                        });
                    }

                    window.pyodideMetrics.fontDownload = performance.now() - stepStart;

                    // Pyodideã®ä»®æƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ä¿å­˜
                    stepStart = performance.now();
                    try {
                        pyodide.FS.writeFile('/NotoSansJP-Bold.ttf', fontBytes);
                        console.log(`ãƒ•ã‚©ãƒ³ãƒˆæ›¸ãè¾¼ã¿æˆåŠŸ: ${fontBytes.length} bytes`);
                    } catch (writeError) {
                        console.error('ãƒ•ã‚©ãƒ³ãƒˆæ›¸ãè¾¼ã¿å¤±æ•—:', writeError);
                        throw writeError; // ä¸Šä½ã®catchã«ä¼æ’­
                    }

                    // æ›¸ãè¾¼ã¿å®Œäº†ã‚’ç¢ºèªï¼ˆstat ã‚’ä½¿ç”¨ï¼‰
                    try {
                        const stat = pyodide.FS.stat('/NotoSansJP-Bold.ttf');
                        console.log(`ãƒ•ã‚©ãƒ³ãƒˆãƒã‚¦ãƒ³ãƒˆç¢ºèª: size=${stat.size}, mode=${stat.mode}`);
                    } catch (e) {
                        console.warn('ãƒ•ã‚©ãƒ³ãƒˆãƒã‚¦ãƒ³ãƒˆç¢ºèªå¤±æ•—:', e);
                        // statå¤±æ•—ã¯warningã®ã¿ï¼ˆæ›¸ãè¾¼ã¿ã¯æˆåŠŸã—ã¦ã„ã‚‹å¯èƒ½æ€§ï¼‰
                    }

                    // æœ€å°å€¤ã‚’ä¿è¨¼ï¼ˆéå¸¸ã«é«˜é€Ÿãªå ´åˆã§ã‚‚0.001msä»¥ä¸Šï¼‰
                    window.pyodideMetrics.fontMount = Math.max(performance.now() - stepStart, 0.001);

                    console.log(`Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆã®${fromCache ? 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥' : 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰'}å®Œäº† (${Math.round(fontBytes.length / 1024 / 1024 * 100) / 100}MB)`);

                    // ãƒ¡ãƒ¢ãƒªè§£æ”¾: ç´„2MBã®ãƒ•ã‚©ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã¯ä½¿ç”¨å¾Œã«æ˜ç¤ºçš„ã«nullåŒ–ã—ã¦GCã‚’ä¿ƒã™
                    fontBytes = null;
                } catch (fontError) {
                    ErrorHandler.logError('FontLoading', fontError);
                    console.warn('Noto Sans JP Bold ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨:', fontError.message);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¨˜éŒ²ï¼ˆã©ã¡ã‚‰ã§å¤±æ•—ã—ãŸã‹åˆ¤æ–­ã§ããªã„å ´åˆã¯ä¸¡æ–¹è¨­å®šï¼‰
                    if (!window.pyodideMetrics.fontDownload) {
                        window.pyodideMetrics.fontDownload = performance.now() - stepStart;
                    }
                    if (!window.pyodideMetrics.fontMount) {
                        window.pyodideMetrics.fontMount = 0.001; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æœ€å°å€¤
                    }
                }

                loadingStatus.innerHTML = '<div class="spinner" style="margin-right: 10px;"></div> Python ã‚³ãƒ¼ãƒ‰ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...';

                stepStart = performance.now();
                pyodide.runPython(labelPythonCode);
                window.pyodideMetrics.pythonCodeLoad = performance.now() - stepStart;

                window.pyodideMetrics.total = performance.now() - window.pyodideMetrics.startTime;

                pythonInitialized = true;
                loadingStatus.classList.remove('show');
                loadingStatus.style.display = 'none';
                form.style.display = 'block';
                document.getElementById('csv-form-container').style.display = 'block';

                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’å‡ºåŠ›
                PyodideDiagnostics.logMetrics();

                showSuccess('åˆæœŸåŒ–å®Œäº†ï¼ãƒ•ã‚©ãƒ¼ãƒ ã«å…¥åŠ›ã—ã¦PDFã‚’ç”Ÿæˆã§ãã¾ã™');

            } catch (error) {
                ErrorHandler.logError('PyodideInitialization', error);
                console.error('Initialization error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                loadingStatus.innerHTML = `<div class="alert alert-error">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${friendlyMsg}</div>`;
            }
        }

        async function generatePDF(event) {
            event.preventDefault();

            if (!pythonInitialized) {
                showError('PythonãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const generateBtn = document.getElementById('generate-btn');
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> PDFç”Ÿæˆä¸­...';

            try {
                // ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿å–å¾—
                const formData = new FormData(event.target);
                const data = {
                    to_postal: formData.get('to_postal').trim(),
                    to_address1: formData.get('to_address1').trim(),
                    to_address2: formData.get('to_address2').trim() || null,
                    to_address3: formData.get('to_address3').trim() || null,
                    to_name: formData.get('to_name').trim(),
                    to_honorific: formData.get('to_honorific').trim() || 'æ§˜',
                    to_phone: formData.get('to_phone').trim() || null,
                    from_postal: formData.get('from_postal').trim(),
                    from_address1: formData.get('from_address1').trim(),
                    from_address2: formData.get('from_address2').trim() || null,
                    from_address3: formData.get('from_address3').trim() || null,
                    from_name: formData.get('from_name').trim(),
                    from_honorific: formData.get('from_honorific').trim(),
                    from_phone: formData.get('from_phone').trim() || null,
                    layout_mode: formData.get('layout_mode')
                };

                // Pythonã§pdfç”Ÿæˆï¼ˆJSONæ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™ï¼‰
                const dataJson = JSON.stringify(data);
                pyodide.globals.set('form_data_json', dataJson);
                const pdfBytes = await pyodide.runPythonAsync(`
import json

# JSONæ–‡å­—åˆ—ã‚’Pythonã®è¾æ›¸ã«å¤‰æ›
form_data = json.loads(form_data_json)

to_info = AddressInfo(
    postal_code=form_data['to_postal'],
    address1=form_data['to_address1'],
    address2=form_data.get('to_address2'),
    address3=form_data.get('to_address3'),
    name=form_data['to_name'],
    phone=form_data.get('to_phone'),
    honorific=form_data['to_honorific'] if form_data['to_honorific'] else None
)

from_info = AddressInfo(
    postal_code=form_data['from_postal'],
    address1=form_data['from_address1'],
    address2=form_data.get('from_address2'),
    address3=form_data.get('from_address3'),
    name=form_data['from_name'],
    phone=form_data.get('from_phone'),
    honorific=form_data['from_honorific'] if form_data['from_honorific'] else None
)

# Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
import os
font_path = '/NotoSansJP-Bold.ttf' if os.path.exists('/NotoSansJP-Bold.ttf') else None

pdf_bytes = create_label_bytes(to_info, from_info, form_data['layout_mode'], font_path=font_path)
pdf_bytes
                `);

                // PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([pdfBytes.toJs()], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'letterpack_label.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showSuccess('PDFã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„');

            } catch (error) {
                ErrorHandler.logError('PDFGeneration', error);
                console.error('PDF generation error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                showError(`PDFç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${friendlyMsg}`);
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'ğŸ“„ PDFã‚’ç”Ÿæˆ';
            }
        }

        async function generateFromCSV(event) {
            event.preventDefault();

            if (!pythonInitialized) {
                showError('PythonãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const csvFileInput = document.getElementById('csv_file');
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                showError('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            const file = csvFileInput.files[0];
            const generateBtn = document.getElementById('generate-csv-btn');
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> CSVå‡¦ç†ä¸­...';

            try {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
                const csvContent = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });

                // Pyodideã§ CSV ã‚’ãƒ‘ãƒ¼ã‚¹
                pyodide.globals.set('csv_content', csvContent);
                const labelData = await pyodide.runPythonAsync(`
import json

try:
    labels = parse_csv_string(csv_content)
    # AddressInfoã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’JSONäº’æ›å½¢å¼ã«å¤‰æ›
    labels_json = []
    for to_info, from_info in labels:
        labels_json.append({
            'to': {
                'postal_code': to_info.postal_code,
                'address': to_info.address,
                'name': to_info.name,
                'phone': to_info.phone,
                'honorific': to_info.honorific
            },
            'from': {
                'postal_code': from_info.postal_code,
                'address': from_info.address,
                'name': from_info.name,
                'phone': from_info.phone,
                'honorific': from_info.honorific
            }
        })

    # JSON å½¢å¼ã§è¿”ã™
    json.dumps(labels_json)
except Exception as e:
    raise ValueError(str(e))
                `);

                // JSON ã‚’ãƒ‘ãƒ¼ã‚¹
                const labelsArray = JSON.parse(labelData);

                // è¤‡æ•°ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆ
                generateBtn.innerHTML = '<span class="spinner" style="margin-right: 10px;"></span> PDFç”Ÿæˆä¸­...';

                pyodide.globals.set('labels_json', JSON.stringify(labelsArray));
                const pdfBytes = await pyodide.runPythonAsync(`
import json

labels_json = pyodide.globals.get('labels_json')
labels_array = json.loads(labels_json)

# AddressInfo ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†æ§‹ç¯‰
label_data_list = []
for label in labels_array:
    to_info = AddressInfo(
        postal_code=label['to']['postal_code'],
        address=label['to']['address'],
        name=label['to']['name'],
        phone=label['to']['phone'],
        honorific=label['to']['honorific']
    )
    from_info = AddressInfo(
        postal_code=label['from']['postal_code'],
        address=label['from']['address'],
        name=label['from']['name'],
        phone=label['from']['phone'],
        honorific=label['from']['honorific']
    )
    label_data_list.append((to_info, from_info))

# Noto Sans JP Bold ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
import os
font_path = '/NotoSansJP-Bold.ttf' if os.path.exists('/NotoSansJP-Bold.ttf') else None

# PDFç”Ÿæˆ
pdf_bytes = create_batch_labels_bytes(label_data_list, font_path=font_path)
pdf_bytes
                `);

                // PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([pdfBytes.toJs()], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'letterpack_labels_batch.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showSuccess(`${labelsArray.length}ä»¶ã®ãƒ©ãƒ™ãƒ«ã‚’CSVã‹ã‚‰ç”Ÿæˆã—ã¾ã—ãŸï¼`);
                csvFileInput.value = '';  // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ

            } catch (error) {
                ErrorHandler.logError('CSVGeneration', error);
                console.error('CSV generation error:', error);
                const friendlyMsg = ErrorHandler.getFriendlyMessage(error);
                showError(`CSVå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${friendlyMsg}`);
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'ğŸ“Š CSVã‹ã‚‰ä¸€æ‹¬ç”Ÿæˆ';
            }
        }

        function downloadSampleCSV() {
            // ã‚µãƒ³ãƒ—ãƒ«CSVãƒ‡ãƒ¼ã‚¿
            const headers = [
                'to_postal',
                'to_address1',
                'to_address2',
                'to_address3',
                'to_name',
                'to_phone',
                'to_honorific',
                'from_postal',
                'from_address1',
                'from_address2',
                'from_address3',
                'from_name',
                'from_phone',
                'from_honorific'
            ];

            const sampleRows = [
                [
                    '123-4567',
                    'æ±äº¬éƒ½æ¸‹è°·åŒºXXX 1-2-3',
                    'XXXãƒ“ãƒ«4F',
                    '',
                    'å±±ç”° å¤ªéƒ',
                    '03-1234-5678',
                    '',
                    '987-6543',
                    'å¤§é˜ªåºœå¤§é˜ªå¸‚YYY 4-5-6',
                    '',
                    '',
                    'ç”°ä¸­ èŠ±å­',
                    '06-9876-5432',
                    ''
                ],
                [
                    '111-2222',
                    'äº¬éƒ½åºœäº¬éƒ½å¸‚ZZZ 7-8-9',
                    '',
                    '',
                    'ä½è—¤ æ¬¡éƒ',
                    '075-111-2222',
                    'æ§˜',
                    '555-6666',
                    'ç¦å²¡çœŒç¦å²¡å¸‚AAA 10-11-12',
                    '',
                    '',
                    'éˆ´æœ¨ ç¾å’²',
                    '092-555-6666',
                    'ä¸€éƒ'
                ]
            ];

            // CSVã‚’ç”Ÿæˆ
            let csv = headers.join(',') + '\n';
            sampleRows.forEach(row => {
                csv += row.map(cell => {
                    // ã‚«ãƒ³ãƒã‚„ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’å«ã‚€å ´åˆã¯ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã‚€
                    if (cell.includes(',') || cell.includes('"')) {
                        return '"' + cell.replace(/"/g, '""') + '"';
                    }
                    return cell;
                }).join(',') + '\n';
            });

            // Blobã‚’ä½œæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([csv], { type: 'text/csv; charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sample.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        document.getElementById('label-form').addEventListener('submit', generatePDF);
        document.getElementById('generate-csv-btn').addEventListener('click', generateFromCSV);
        document.getElementById('download-sample-csv-btn').addEventListener('click', downloadSampleCSV);

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«åˆæœŸåŒ–
        window.addEventListener('load', initPyodide);
    </script>
</body>
</html>
